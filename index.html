<html>
<head>
    <meta charset="UTF-8" />
    <title>INFO 3300 Project 1</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        .gridlines line {
        stroke: #bbb;
        }
        
        .gridlines .domain {
        stroke: none;
        }

        .label text {
            color: black;
        }
    </style>

</head>

<body>
    <div id="plot1">
        <svg id="scatterplot" height="500" width= "1000">
        </svg>
    </div>

    <div id="legend">
        <svg id="legendsvg" height = "200" width="800"></svg>
    </div>
    <script>

        // setting up svg
        const svg1 = d3.select('svg#scatterplot')

        const width = svg1.attr("width");
        const height = svg1.attr("height");
        const margin = {top: 10, right: 30, bottom: 40, left: 100};
        
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;

        let labels = svg1.append('g').attr('id', 'labels');
        let chartArea = svg1.append("g").attr("id","boxOffice")
                            .attr("transform","translate("+margin.left+","+margin.top+")");
                
        // making a dictionary to label the months in abbreviations instead of letters
        const monthsDict = {1: 'Jan', 2: 'Feb', 3: 'Mar', 4: 'Apr', 5: 'May', 6: 'Jun', 7: 'Jul', 8: 'Aug', 9: 'Sep', 10: 'Oct', 11: 'Nov', 12: 'Dec'};

        let genres = {};
        d3.csv('../disney_movies_total_gross.csv').then( (genreData) => {
            
            // removing empty values for the genre/total gross income data set
            genreData = genreData.filter( (d) => {return d['genre'] != "";}  );
            genreData = genreData.filter( (d) => {return d['total_gross'] != 0;}  );

            //trying to remove duplicate titles for the genres data set
            var genreTitles = [...new Set(genreData.map(function(d) {
                return d['movie_title']
            }))];
            
            genreData = genreTitles.map(function(d) {
                return genreData.find(function(e) {
                    return e['movie_title'] === d
                })
            });

            // making a map with the movie title as the key
            genres = d3.index(genreData, d => d['movie_title']);
            //console.log(genres);
   
        });

        


        // promise for second data set, which has box office profits data, release dates and movie titles

        d3.csv('../disney.csv').then( (data) => {

            // removing empty values for the box office/budget data set 
            // I removed empty values for the budget, box office, title, and release date
            data = data.filter( (d) => {return d['Budget (float)'] != "";}  );
            data = data.filter( (d) => {return d['Box office (float)'] != "" && d['Box office (float)'] != "0";}  );
            data = data.filter( (d) => {return d['title'] != "";}  );
            data = data.filter( (d) => {return d['Release date (datetime)'] != '';});
            
            //trying to remove duplicate titles
            var titles = [...new Set(data.map(function(d) {
                return d.title
            }))];
            data = titles.map(function(d) {
                return data.find(function(e) {
                    return e.title === d
                })
            });
            //console.log(data);


            // coercing the box office values to numbers, split the string of release dates to get the month as a number
            data.forEach( (d, i) => {
                d['Box'] = Number( d['Box office (float)']);
                d['Release date (datetime)'] = d['Release date (datetime)'].split("-");
                d['monthNum'] = Number(d['Release date (datetime)'][1]);
                d['month'] = monthsDict[d['monthNum']];
            })


            // removing box office values that were unreasonably low (some values were less than 200, which did not make sense)
            data = data.filter( (d) => {return d['Box'] > 200 ;} );
            //console.log(data);


            // extents and scales
            const boxExtent = d3.extent(data, d => d['Box']);
            //using a Log scale so there is a better separation of values and not too many values clustered at the bottom
            const boxScale = d3.scaleLog().domain(boxExtent).range([chartHeight, margin.bottom]);


            // const months = d3.map(data, d => d.month)
            // console.log(months);
            const monthScale = d3.scalePoint().domain(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']).range([margin.left, chartWidth]).padding(0.1);


            // making axes and gridlines
            let leftAxis = d3.axisLeft(boxScale).tickFormat("");
            let leftGridlines = d3.axisLeft(boxScale)
                                    .tickSize(-chartWidth+55)
                                    .tickFormat(d3.format("~f"));

            labels.append("g")
                .attr("class", "y gridlines")
                .attr("transform","translate("+(margin.left-15)+","+margin.top+")")
                .call(leftGridlines);
            labels.append("g")
                .attr("class", "y axis")
                .attr("transform","translate("+(margin.left-10)+","+margin.top+")")
                .call(leftAxis)


            let bottomAxis = d3.axisBottom(monthScale).tickFormat("");
            let bottomGridlines = d3.axisBottom(monthScale).tickSize(-chartHeight+20);
              
            labels.append("g")
                    .attr("class", "x gridlines")
                    .attr("transform","translate("+0+","+(chartHeight+margin.top+10)+")")
                    .call(bottomGridlines);
            labels.append("g")
                    .attr("class", "x axis")
                    .attr("transform","translate("+0+","+(chartHeight+margin.top)+")")
                    .call(bottomAxis);
            

          
            

            // combining two datasets to have one array with the movie title, genre and box office profits
            let profitsGenres = d3.index(data, d => d.title);
            // console.log(profitsGenres);
            // console.log(genres);

            // this 'data' is now a combined dataset to help graph multiple attributes
            data = data.map(({title: name, month, Box}) => ({name, month, Box, ...genres.get(name)}));
            console.log(data);


            // making a custom color scale to color each data point by genre
            const genreScale = d3.scaleOrdinal()
                                       .domain(["Musical", "Comedy", "Romantic Comedy", "Documentary", "Adventure", "Horror", "Western", "Action", "Drama", "Thriller/Suspense", "Black Comedy", "Concert/Performance"])
                                       .range(["#31709B", "#EFA23D", "#AC5D9E", "#569B7E", "#9BC7D2", "#FBD26E", "#D282B4", "#77C8A6", "#B591F3", "#FCE7AB", "#F5A7A8", "#E2BB9D"]);

            // adding circles for data points
            let circles = chartArea.selectAll("circle").data(data)
                                   .join("circle")
                                   .attr("cx", d => monthScale(d['month'])-margin.left + jitter())
                                   .attr("cy", d => boxScale(d['Box'])+jitter())
                                   .attr("r", 5)
                                   .style('fill', d => genreScale(d['genre']))
                                   .attr('opacity', 0.8);

            // FIX THIS
            // creating text for axis labels
            chartArea.append("text")
                    .attr('class', 'x label')
                    .attr('text-anchor', 'middle')
                    .attr('x', '500')
                    .attr('y', '500')
                    .attr('text', 'release month');

            const legendRows = {first: 20, second: 50, third: 80};
            const legendCols = {first: margin.left, second: margin.left + 130, third: margin.left + 300, fourth: margin.left + 450};
            

            // FIGURE OUT A SCRIPT TO DO THIS
            // figure legend
            const legend = d3.select('svg#legendsvg');
            legend.append("circle").attr("cx", legendCols.first).attr("cy",legendRows.first).attr("r", 6).style("fill", "#31709B");
            legend.append("text").attr("x", legendCols.first + 20).attr("y", legendRows.first).text("Musical").style("font-size", "15px").style("font-family", "avenir").attr("alignment-baseline","middle")
            legend.append("circle").attr("cx", legendCols.first).attr("cy",legendRows.second).attr("r", 6).style("fill", "#9BC7D2");
            legend.append("text").attr("x", legendCols.first + 20).attr("y", legendRows.second).text("Adventure").style("font-size", "15px").style("font-family", "avenir").attr("alignment-baseline","middle")
            legend.append("circle").attr("cx", legendCols.first).attr("cy",legendRows.third).attr("r", 6).style("fill", "#B591F3");
            legend.append("text").attr("x", legendCols.first + 20).attr("y", legendRows.third).text("Drama").style("font-size", "15px").style("font-family", "avenir").attr("alignment-baseline","middle")

            legend.append("circle").attr("cx", legendCols.second).attr("cy",legendRows.first).attr("r", 6).style("fill", "#EFA23D");
            legend.append("text").attr("x", legendCols.second + 20).attr("y", legendRows.first).text("Comedy").style("font-size", "15px").style("font-family", "avenir").attr("alignment-baseline","middle")
            legend.append("circle").attr("cx", legendCols.second).attr("cy",legendRows.second).attr("r", 6).style("fill", "#FBD26E");
            legend.append("text").attr("x", legendCols.second + 20).attr("y", legendRows.second).text("Horror").style("font-size", "15px").style("font-family", "avenir").attr("alignment-baseline","middle")
            legend.append("circle").attr("cx", legendCols.second).attr("cy",legendRows.third).attr("r", 6).style("fill", "#FCE7AB");
            legend.append("text").attr("x", legendCols.second + 20).attr("y", legendRows.third).text("Thriller/Suspense").style("font-size", "15px").style("font-family", "avenir").attr("alignment-baseline","middle")

            legend.append("circle").attr("cx", legendCols.third).attr("cy",legendRows.first).attr("r", 6).style("fill", "#AC5D9E");
            legend.append("text").attr("x", legendCols.third + 20).attr("y", legendRows.first).text("Romantic Comedy").style("font-size", "15px").style("font-family", "avenir").attr("alignment-baseline","middle")
            legend.append("circle").attr("cx", legendCols.third).attr("cy",legendRows.second).attr("r", 6).style("fill", "#D282B4");
            legend.append("text").attr("x", legendCols.third + 20).attr("y", legendRows.second).text("Western").style("font-size", "15px").style("font-family", "avenir").attr("alignment-baseline","middle")
            legend.append("circle").attr("cx", legendCols.third).attr("cy",legendRows.third).attr("r", 6).style("fill", "#F5A7A8");
            legend.append("text").attr("x", legendCols.third + 20).attr("y", legendRows.third).text("Black Comedy").style("font-size", "15px").style("font-family", "avenir").attr("alignment-baseline","middle")

            // // making a temporary figure legend
            // genreScale.domain().forEach( function (d,i) {
            //     d3.select("#legend")
            //     .append("span")
            //     .text(d)
            //     .style("color", genreScale(d))
            // });
  

                
 
        });

       


        // // list of genres
        // let genres = []
        // genredata.forEach( (d,i) => {
        //         if (!(genres.includes(d['genre']) )) {
        //             genres.push(d['genre'])
        //         }
        //     // console.log(genres.length)
        //     })

        // jitter helper function
        function jitter () {
                return Math.floor(Math.random() * (8) + (-4)) ;
            }
    </script>

<!-- QUESTIONS: use log scale or linear scale? use jitter function? -->
</body>
</html>
