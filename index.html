<html>
<head>
    <meta charset="UTF-8" />
    <title>INFO 3300 Project 1</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        .gridlines line {
        stroke: #bbb;
        }
        
        .gridlines .domain {
        stroke: none;
        }
    </style>

</head>

<body>
    <div id="plot1">
        <svg id="scatterplot" height="500" width= "1000">
        </svg>
    </div>
    <script>

        // setting up svg
        const svg1 = d3.select('svg#scatterplot')

            
            const width = svg1.attr("width");
            const height = svg1.attr("height");
            const margin = {top: 10, right: 30, bottom: 40, left: 100};
            

            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            let labels = svg1.append('g').attr('id', 'labels');
            let chartArea = svg1.append("g").attr("id","boxOffice")
                                .attr("transform","translate("+margin.left+","+margin.top+")");

            // making a dictionary to label the months in abbreviations instead of letters
            const monthsDict = {1: Jan, 2: Feb, 3: Mar, 4: Apr, 5: May, 6: Jun, 7: Jul, 8: Aug, 9: Sep, 10: Oct, 11: Nov, 12: Dec};

        // removing empty values for the box office/budget data set. I removed empty values for the budget, box office, title, and release date
        d3.csv('../disney.csv').then( (data) => {

            data = data.filter( (d) => {return d['Budget (float)'] != "";}  );
            data = data.filter( (d) => {return d['Box office (float)'] != "" && d['Box office (float)'] != "0";}  );
            data = data.filter( (d) => {return d['title'] != "";}  );
            data = data.filter( (d) => {return d['Release date (datetime)'] != '';});

            // coercing the box office values to numbers, split the string of release dates to get the month as a number
            data.forEach( (d, i) => {
                d['Box office (float)'] = Number( d['Box office (float)']);
                d['Release date (datetime)'] = d['Release date (datetime)'].split("-");
                d['month'] = monthsDict(Number(d['Release date (datetime)'][1]));
            })
            console.log(data);


            // removing box office values that were unreasonably low (some values were less than 200, which did not make sense)
            data = data.filter( (d) => {return d['Box office (float)'] > 200 ;} );
            console.log(data);

            // extents and scales

            const boxExtent = d3.extent(data, d => d['Box office (float)']);
            console.log(boxExtent);
            const boxScale = d3.scaleLinear().domain(boxExtent).range([chartHeight, margin.bottom]);

            


            // making axes and gridlines
            let leftAxis = d3.axisLeft(boxScale).tickFormat("");
            let leftGridlines = d3.axisLeft(boxScale)
                                    .tickSize(-chartWidth-10)
                                    .tickFormat(d3.format("~f"));
            labels.append("g")
                .attr("class", "y axis")
                .attr("transform","translate("+(margin.left)+","+margin.top+")")
                .call(leftAxis)
            labels.append("g")
                .attr("class", "y gridlines")
                .attr("transform","translate("+(margin.left)+","+margin.top+")")
                .call(leftGridlines);

 
        });

        // removing empty values for the genre/total gross income data set
        d3.csv('../disney_movies_total_gross.csv').then( (data) => {
            data = data.filter( (d) => {return d['genre'] != "";}  );
            data = data.filter( (d) => {return d['total_gross'] != 0;}  );
          //  console.log(data);

            // list of genres
            let genres = [];
            data.forEach( (d,i) => {
                if (!(genres.includes(d['genre']) )) {
                    genres.push(d['genre'])
                }
           // console.log(genres.length)
            })
        });


        // HELP WITH THIS PART

        // function to parse through both datasets
        const parseData = async () => {
            var disney1 = await d3.csv('../disney.csv')
            var disney2 = await d3.csv('../disney_movies_total_gross.csv')
            disney1.forEach( (d,i) => {
                console.log(d['title']);
            })
        }


         
    </script>

</body>
</html>
