<html>
<head>
    <meta charset="UTF-8" />
    <title>INFO 3300 Project 1</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        .gridlines line {
        stroke: #bbb;
        }
        
        .gridlines .domain {
        stroke: none;
        }
    </style>

</head>

<body>
    <div id="plot1">
        <svg id="scatterplot" height="500" width= "1000">
        </svg>
    </div>
    <script>

        // setting up svg
        const svg1 = d3.select('svg#scatterplot')

        const width = svg1.attr("width");
        const height = svg1.attr("height");
        const margin = {top: 10, right: 30, bottom: 40, left: 100};
        
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;

        let labels = svg1.append('g').attr('id', 'labels');
        let chartArea = svg1.append("g").attr("id","boxOffice")
                            .attr("transform","translate("+margin.left+","+margin.top+")");

        // making a dictionary to label the months in abbreviations instead of letters
        const monthsDict = {1: 'Jan', 2: 'Feb', 3: 'Mar', 4: 'Apr', 5: 'May', 6: 'Jun', 7: 'Jul', 8: 'Aug', 9: 'Sep', 10: 'Oct', 11: 'Nov', 12: 'Dec'};

        // making a map for titles/genres
        let genres = [];

        // removing empty values for the genre/total gross income data set
        d3.csv('../disney_movies_total_gross.csv').then( (genredata) => {
            genredata = genredata.filter( (d) => {return d['genre'] != "";}  );
            genredata = genredata.filter( (d) => {return d['total_gross'] != 0;}  );

            let genres = d3.index(genredata, d => d.name)
            
        });
        console.log(genres);
        


        // promise for second data set, which has box office profits data, release dates and movie titles

        d3.csv('../disney.csv').then( (data) => {

            // removing empty values for the box office/budget data set 
            // I removed empty values for the budget, box office, title, and release date
            data = data.filter( (d) => {return d['Budget (float)'] != "";}  );
            data = data.filter( (d) => {return d['Box office (float)'] != "" && d['Box office (float)'] != "0";}  );
            data = data.filter( (d) => {return d['title'] != "";}  );
            data = data.filter( (d) => {return d['Release date (datetime)'] != '';});
            
            //trying to remove duplicate titles
            var titles = [...new Set(data.map(function(d) {
                return d.title
            }))];
            data = titles.map(function(d) {
                return data.find(function(e) {
                    return e.title === d
                })
            });
            console.log(data);

            // coercing the box office values to numbers, split the string of release dates to get the month as a number
            data.forEach( (d, i) => {
                d['Box office (float)'] = Number( d['Box office (float)']);
                d['Release date (datetime)'] = d['Release date (datetime)'].split("-");
                d['monthNum'] = Number(d['Release date (datetime)'][1]);
                d['month'] = monthsDict[d['monthNum']];
            })


            // removing box office values that were unreasonably low (some values were less than 200, which did not make sense)
            data = data.filter( (d) => {return d['Box office (float)'] > 200 ;} );
            console.log(data);

            // extents and scales

            const boxExtent = d3.extent(data, d => d['Box office (float)']);
            console.log(boxExtent);
            const boxScale = d3.scaleLinear().domain(boxExtent).range([chartHeight, margin.bottom]);

            // const months = d3.map(data, d => d.month)
            // console.log(months);
            const monthScale = d3.scalePoint().domain(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']).range([margin.left, chartWidth]).padding(0.1);


            // making axes and gridlines
            let leftAxis = d3.axisLeft(boxScale).tickFormat("");
            let leftGridlines = d3.axisLeft(boxScale)
                                    .tickSize(-chartWidth+55)
                                    .tickFormat(d3.format("~f"));

            labels.append("g")
                .attr("class", "y gridlines")
                .attr("transform","translate("+(margin.left-15)+","+margin.top+")")
                .call(leftGridlines);
            labels.append("g")
                .attr("class", "y axis")
                .attr("transform","translate("+(margin.left-10)+","+margin.top+")")
                .call(leftAxis)



            let bottomAxis = d3.axisBottom(monthScale).tickFormat("");
            let bottomGridlines = d3.axisBottom(monthScale).tickSize(-chartHeight+20);
              
            labels.append("g")
                    .attr("class", "x gridlines")
                    .attr("transform","translate("+0+","+(chartHeight+margin.top+10)+")")
                    .call(bottomGridlines);
            labels.append("g")
                    .attr("class", "x axis")
                    .attr("transform","translate("+0+","+(chartHeight+margin.top)+")")
                    .call(bottomAxis);
            
            // wanting to join 2 datasets
            let index = d3.index(data, d => d.title);
            console.log(index);

                
 
        });

       

        


        // HELP WITH THIS PART

        // function to parse through both datasets
        const parseData = async () => {
            var disney1 = await d3.csv('../disney.csv')
            var disney2 = await d3.csv('../disney_movies_total_gross.csv')
            
        }

        // // list of genres

        // genredata.forEach( (d,i) => {
        //         if (!(genres.includes(d['genre']) )) {
        //             genres.push(d['genre'])
        //         }
        //     // console.log(genres.length)
        //     })
         
    </script>

</body>
</html>
